# -*- coding: utf-8 -*-
"""lab 6 Task 3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1co5ezc_XHE6FF_lcpQt0maz30WHOOsFs
"""

#task 3

import heapq as hq

def safestpath(N, edges):
    graph = [[] for i in range(N + 1)]
    for u, v, w in edges:
        graph[u].append((v, w))
        graph[v].append((u, w))

    distance = [float('inf')] * (N+1)
    distance[1] = 0

    priorQ = [(0, 1)]

    while priorQ:
        dist, node = hq.heappop(priorQ)

        if dist > distance[node]:
            continue

        for neighbor, danger in graph[node]:
            new_danger = max(danger, distance[node])
            if new_danger < distance[neighbor]:
                distance[neighbor] = new_danger
                hq.heappush(priorQ, (new_danger, neighbor))

    if distance[N] == float('inf'):
        return "Impossible"
    else:
        return distance[N]

with open("/content/input3.txt", "r") as txt_input, open("/content/output3.txt", "w") as txt_output:

    N, M = map(int, txt_input.readline().split())
    edges = []

    for i in range(M):
        u, v, w = map(int, txt_input.readline().split())
        edges.append((u, v, w))

    result = safestpath(N, edges)
    print(result, file = txt_output)
txt_output.close()